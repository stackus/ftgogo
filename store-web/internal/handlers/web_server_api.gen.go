// Package handlers provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.7.0 DO NOT EDIT.
package handlers

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	externalRef0 "github.com/stackus/ftgogo/serviceapis/commonapi"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for OrderState.
const (
	OrderStateApprovalPending OrderState = "ApprovalPending"

	OrderStateApproved OrderState = "Approved"

	OrderStateCancelPending OrderState = "CancelPending"

	OrderStateCancelled OrderState = "Cancelled"

	OrderStateRejected OrderState = "Rejected"

	OrderStateRevisionPending OrderState = "RevisionPending"

	OrderStateUnknown OrderState = "Unknown"
)

// Account defines model for Account.
type Account struct {
	AccountId string `json:"account_id"`
	Enabled   bool   `json:"enabled"`
}

// DeliveryHistory defines model for DeliveryHistory.
type DeliveryHistory struct {
	AssignedCourier string   `json:"assigned_courier"`
	CourierActions  []string `json:"courier_actions"`
	Id              string   `json:"id"`
	Status          string   `json:"status"`
}

// MenuItem defines model for MenuItem.
type MenuItem struct {
	Id    string `json:"id"`
	Name  string `json:"name"`
	Price int    `json:"price"`
}

// Order defines model for Order.
type Order struct {
	OrderId    string     `json:"order_id"`
	OrderTotal int        `json:"order_total"`
	Status     OrderState `json:"status"`
}

// OrderState defines model for OrderState.
type OrderState string

// Restaurant defines model for Restaurant.
type Restaurant struct {
	Address externalRef0.Address `json:"address"`
	Id      string               `json:"id"`
	Menu    struct {
		MenuItems []MenuItem `json:"menu_items"`
	} `json:"menu"`
	Name string `json:"name"`
}

// AccountID defines model for AccountID.
type AccountID string

// ConsumerID defines model for ConsumerID.
type ConsumerID string

// CourierID defines model for CourierID.
type CourierID string

// DeliveryID defines model for DeliveryID.
type DeliveryID string

// OrderID defines model for OrderID.
type OrderID string

// RestaurantID defines model for RestaurantID.
type RestaurantID string

// AccountIDResponse defines model for AccountIDResponse.
type AccountIDResponse struct {
	Id string `json:"id"`
}

// AccountResponse defines model for AccountResponse.
type AccountResponse struct {
	Account Account `json:"account"`
}

// ConsumerResponse defines model for ConsumerResponse.
type ConsumerResponse struct {
	ConsumerId string `json:"consumer_id"`
	Name       string `json:"name"`
}

// CourierAvailableResponse defines model for CourierAvailableResponse.
type CourierAvailableResponse struct {
	Available bool `json:"available"`
}

// DeliveryHistoryResponse defines model for DeliveryHistoryResponse.
type DeliveryHistoryResponse struct {
	DeliveryHistory DeliveryHistory `json:"delivery_history"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Message string `json:"message"`
}

// OrderResponse defines model for OrderResponse.
type OrderResponse struct {
	Order Order `json:"order"`
}

// OrderStatusResponse defines model for OrderStatusResponse.
type OrderStatusResponse struct {
	Status OrderState `json:"status"`
}

// RestaurantIDResponse defines model for RestaurantIDResponse.
type RestaurantIDResponse struct {
	Id string `json:"id"`
}

// RestaurantResponse defines model for RestaurantResponse.
type RestaurantResponse Restaurant

// SetCourierAvailabilityJSONBody defines parameters for SetCourierAvailability.
type SetCourierAvailabilityJSONBody struct {
	Available bool `json:"available"`
}

// CreateRestaurantJSONBody defines parameters for CreateRestaurant.
type CreateRestaurantJSONBody struct {
	Address externalRef0.Address `json:"address"`
	Menu    struct {
		MenuItems []MenuItem `json:"menu_items"`
	} `json:"menu"`
	Name string `json:"name"`
}

// SetCourierAvailabilityJSONRequestBody defines body for SetCourierAvailability for application/json ContentType.
type SetCourierAvailabilityJSONRequestBody SetCourierAvailabilityJSONBody

// CreateRestaurantJSONRequestBody defines body for CreateRestaurant for application/json ContentType.
type CreateRestaurantJSONRequestBody CreateRestaurantJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /accounts/{accountID})
	GetAccount(w http.ResponseWriter, r *http.Request, accountID AccountID)

	// (PUT /accounts/{accountID}/disable)
	DisableAccount(w http.ResponseWriter, r *http.Request, accountID AccountID)

	// (PUT /accounts/{accountID}/enable)
	EnableAccount(w http.ResponseWriter, r *http.Request, accountID AccountID)

	// (GET /consumers/{consumerID})
	GetConsumer(w http.ResponseWriter, r *http.Request, consumerID ConsumerID)

	// (POST /couriers/{courierID}/availability)
	SetCourierAvailability(w http.ResponseWriter, r *http.Request, courierID CourierID)

	// (GET /deliveries/{deliveryID})
	GetDeliveryHistory(w http.ResponseWriter, r *http.Request, deliveryID DeliveryID)

	// (GET /orders/{orderID})
	GetOrder(w http.ResponseWriter, r *http.Request, orderID OrderID)

	// (PUT /orders/{orderID}/cancel)
	CancelOrder(w http.ResponseWriter, r *http.Request, orderID OrderID)

	// (POST /restaurants)
	CreateRestaurant(w http.ResponseWriter, r *http.Request)

	// (GET /restaurants/{restaurantID})
	GetRestaurant(w http.ResponseWriter, r *http.Request, restaurantID RestaurantID)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// GetAccount operation middleware
func (siw *ServerInterfaceWrapper) GetAccount(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "accountID" -------------
	var accountID AccountID

	err = runtime.BindStyledParameter("simple", false, "accountID", chi.URLParam(r, "accountID"), &accountID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accountID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetAccount(w, r, accountID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DisableAccount operation middleware
func (siw *ServerInterfaceWrapper) DisableAccount(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "accountID" -------------
	var accountID AccountID

	err = runtime.BindStyledParameter("simple", false, "accountID", chi.URLParam(r, "accountID"), &accountID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accountID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DisableAccount(w, r, accountID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// EnableAccount operation middleware
func (siw *ServerInterfaceWrapper) EnableAccount(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "accountID" -------------
	var accountID AccountID

	err = runtime.BindStyledParameter("simple", false, "accountID", chi.URLParam(r, "accountID"), &accountID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter accountID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.EnableAccount(w, r, accountID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetConsumer operation middleware
func (siw *ServerInterfaceWrapper) GetConsumer(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "consumerID" -------------
	var consumerID ConsumerID

	err = runtime.BindStyledParameter("simple", false, "consumerID", chi.URLParam(r, "consumerID"), &consumerID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter consumerID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetConsumer(w, r, consumerID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// SetCourierAvailability operation middleware
func (siw *ServerInterfaceWrapper) SetCourierAvailability(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "courierID" -------------
	var courierID CourierID

	err = runtime.BindStyledParameter("simple", false, "courierID", chi.URLParam(r, "courierID"), &courierID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter courierID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetCourierAvailability(w, r, courierID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetDeliveryHistory operation middleware
func (siw *ServerInterfaceWrapper) GetDeliveryHistory(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "deliveryID" -------------
	var deliveryID DeliveryID

	err = runtime.BindStyledParameter("simple", false, "deliveryID", chi.URLParam(r, "deliveryID"), &deliveryID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter deliveryID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDeliveryHistory(w, r, deliveryID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetOrder operation middleware
func (siw *ServerInterfaceWrapper) GetOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderID" -------------
	var orderID OrderID

	err = runtime.BindStyledParameter("simple", false, "orderID", chi.URLParam(r, "orderID"), &orderID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter orderID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOrder(w, r, orderID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CancelOrder operation middleware
func (siw *ServerInterfaceWrapper) CancelOrder(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "orderID" -------------
	var orderID OrderID

	err = runtime.BindStyledParameter("simple", false, "orderID", chi.URLParam(r, "orderID"), &orderID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter orderID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelOrder(w, r, orderID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// CreateRestaurant operation middleware
func (siw *ServerInterfaceWrapper) CreateRestaurant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateRestaurant(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// GetRestaurant operation middleware
func (siw *ServerInterfaceWrapper) GetRestaurant(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "restaurantID" -------------
	var restaurantID RestaurantID

	err = runtime.BindStyledParameter("simple", false, "restaurantID", chi.URLParam(r, "restaurantID"), &restaurantID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter restaurantID: %s", err), http.StatusBadRequest)
		return
	}

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{""})

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetRestaurant(w, r, restaurantID)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/accounts/{accountID}", wrapper.GetAccount)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/accounts/{accountID}/disable", wrapper.DisableAccount)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/accounts/{accountID}/enable", wrapper.EnableAccount)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/consumers/{consumerID}", wrapper.GetConsumer)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/couriers/{courierID}/availability", wrapper.SetCourierAvailability)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/deliveries/{deliveryID}", wrapper.GetDeliveryHistory)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/orders/{orderID}", wrapper.GetOrder)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/orders/{orderID}/cancel", wrapper.CancelOrder)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/restaurants", wrapper.CreateRestaurant)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/restaurants/{restaurantID}", wrapper.GetRestaurant)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9xZ3Y7bNhN9FYHfd9ECgumkN4XvttkkdYtig2yCXATGgpbGNhOJVEjKrWHo3QtSpERb",
	"lCX/LJoWWCwskRyeORweDkd7lPC84AyYkmi2RwURJAcFwjzdJQkvmZrf64cUZCJooShnaIZI3RTRNPqh",
	"LGn6I4oR1Q0FURsUI0ZyaLvN71GMBHwrqYAUzZQoIUYy2UBOtOkVFzlRaIa0JRQjtSv0YKkEZWtUVTF6",
	"xZkscxAhKIltG8KStDauBVMK2ofFNA1DcRauQ3IPGd2C2IWgpLZtCEva2rgOzINIw6Rw3TAEg9vR12F4",
	"D1KRUpBw0IqmdQiN8O1cA6nSg2XBmYTDLfXevtUvE84UMKV/kqLIaEI0YPxFatR7b7ZC8AKEorUtmur/",
	"XRJatJ91n0WDii+/QKJqVIfMPPyOqtiBuwE0u+/1z/8LWKEZ+h9ulQbXwyS2E3ZQu+HjoTuBuAF2pxNP",
	"QX5diAwR71uxY87xxujD3ZbQjCwzuMWKOFse9CXnGRDWpb/pOx6yk6JfqVRc7G6A2AnT06Y2ORRMRwg6",
	"XnXsjXfutRD8FqGVg5RkPSJ6XMcxED8y+KuAREEaGZzIafENABtVHiLeTNZxoR46nmNj5VERVcobAJfG",
	"0Cjkek7owLcGxuP3j57vUdxbfBehO0Vja7pv+sqdmf4h2Hts9CkvMC1K6RgFaw21w7pcdWQrAElKumaQ",
	"PtmcLQjMtj2RRPtcr5+CXAY72xdECLLTz7WzA4lE7EX0YFA0neMu/C7YEC1/ACvnCvKRcdl7KMaoEDTx",
	"WyhTsA7IRXtMujEhXA9OjwIy1Rc1daPiimQhHPH1WtFM7xHvz9rrSW1utkfAylxb+si+Mv4nQzG6KwrB",
	"tyR7ByzVjrg3oGd5D1+M4KMYvSIsAa9X/ZzZblsqKWeudREIK2/vdmM/TQVIn5nJBNd/EsSWJkAKKjVZ",
	"OWekoFgWkEx2JM/C2Z41Nz7mc2Bl6BRl5VOzv5ofpxaviefO/uscvI3t0KqNy/38WHYcWmcCeh0jCUkp",
	"qNo9arS1j0sgAsRdqTbt0xtH12+fPiArqEYETWvL30apohZiylbcqTxJzArbC86bD28f3j5EcylL0OBK",
	"kdmRcobxmqpNuZwkPMdSkeRrKfFKrfmaY1oP6Ij8hw1Ej4oLiD7BMrp7N4+ojAoiVMRXkdpAZCdMIedM",
	"KmGOmcg7cjR8qnR6ig7soBhtQch6lheT6WRq9nQBOuDQDP1kXsXm/maYw1b7Jd431YdKN6zBEKAjycw4",
	"T9EMvQXlTqP4oPrxORxQbRfcVkeqxdEt7+V02heRTT98fNsynK5ImanhsYcJaWUWO+g4Tql0WX9RBgi4",
	"r9v/YRK8lOl5aKhzgF4WXrP/GAnu+inxvq17ndwG7gZ9tvdebe4y9zt39xt4b1Ic47yttFXY3mppRlWd",
	"53EZYOJRM+Hfvuv+55PiKnw1J99KkOoXnu6+yyu8K1v6FEUWdKf8VV22xj0VjavX2l7rKUi8b2uZJ0P9",
	"OOk/d3G9sutlEd9XLLmaDJN1Sry31dSTLNS59Lm+uyrvZY4f1iWucbfNmgxqP1/6vKgWQTZwYpLj3lOg",
	"zp1vzsvLkbwcFT+em522xi375fCVAKLAuyTcTMye7W7xL700jL4vdNXbrFHkfd0YL90vhmMrWNi6Wqm8",
	"6MN7/3PLSc06CMTzNujBp6HL1CtQQruOh6N9WsXdrap7iK3zsb2mzTDeb7hU1WxfcKEqrK9DMdoSQfX5",
	"apza2C3dIEQZT0hmXlcx0uMOm3+eTl9oYIvq7wAAAP//gcfxuBkeAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	pathPrefix := path.Dir(pathToFile)

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(pathPrefix, "../../../serviceapis/commonapi/spec.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
